---
title: 数据库的并发控制
date: 2019-08-01 00:33:44
categories:
- 数据库
tags: [数据库数据库系统概论,计算机基础,核心知识]
---

```markdown
1.为什么要对数据库进行并发控制
2.并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况
3.并发控制技术的目的是什么
4.```可串行化调度```和```可串行性``` 的联系与区别。
5.调度的可串行性存在的原因，如何保证并发调度的可串行性
6.并发控制方法有哪些，每种方法是如何实现的，每种方法的优缺点是什么，并发控制方法解决了什么问题
```

## 事务的并行运行带来的问题

数据对象对事务来说是共享资源，事务在并发运行时，由于并发操作的```不正确调度```，容易造成数据不一致的问题。数据不一致可分为三类：修改丢失、不可重复读和脏读。
事务的并行运行破坏了事务的隔离性和一致性。

通过一个具体的实例来理解一下数据不一致
a.甲售票点读出某航班剩余票数A，设A=16
b.乙售票点读出统一航班剩余票数A，A也是16
c.甲售票点卖出一张票，修改剩余票数A=A-1=15，将剩余票数写回数据库
d.乙售票点卖出一张票，修改剩余票数A=A-1=15，将剩余票数写回数据库

此时发现明明卖出了两张票，剩余票数却只修改了1，破坏了数据库的一致性

数据的不一致性表现为

* ```丢失修改```
  两个事务(T1,T2)同时读取A的值,T2的提交结果破坏了T1的提交结果，导致T1的修改丢失
  
* 不可重复读
  根据事务T2的操作(修改、删除、新增)，可细分为三种情况
  事务T1读取数据A后，事务T2提交了对A的修改，导致事务T1读取的A值与之前不一样
  事务T1读取数据A后，事务T2提交了对A的删除，导致事务T1读不到A的值
  事务T1读取数据A后，事务T2提交了对A的新增，导致事务T1读到了两个A值

  后两种情况又称为幻影现象

* 脏读(读不正确的数据)
  事务T1修改了A的值并提交，事务T2读取A的值，此时事务T1因为某种原因撤销提交，A恢复原值，T2读到的数据A与数据库中的数据A不一致

## 并发调度的可串行性

### 问题

不同事务的调度是由DBMS来完成的。DBMS对事务不同的调度策略可能会产生不同的结果，那么什么样的调度是正确的的呢？

### 可串行化调度

#### 什么是可串行化调度

多个事务的并发结果是正确的，当且仅当其结果与按某一次序串行执行这些事务的结果相同时，则称这次的调度策略是```可串行化的```

```可串行性```是并发事务正确调度的准则。一个给定的并发调度，当且仅当他是```可串行化```的，才认为他是```正确调度```

#### 冲突操作

冲突操作是指不同事务对同一数据对象的读写操作和写写操作，其他操作是非冲突操作
```不同事务的冲突操作和同一事务的两个操作是不能交换的```

#### 具有什么样性质的调度是可串行化的调度，如何判断调度是可串行化的调度

一个调度Sc在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作，得到一个新的调度Sc'，若Sc'是串行的，则Sc'被称为冲突可串行化的调度
```若一个调度是冲突可串行化，则这个调度是可串行化调度```
```冲突可串行化调度是可串行化调度的充分条件。存在不满足冲突可串行化条件的可串行化调度```

举例来说明以上内容

## 并发控制的技术

### 目的

解决数据不一致的问题，保证调度的可串行性

* 封锁(locking)
* 时间戳(timestamp)
* 乐观控制法(optimistc scheduler)
* 多版本并发控制(multi-version concurrency contral ,MVCC)

### 封锁

#### 含义

事务在访问数据对象(表、记录、字段)，向系统申请，对所要访问的数据对象加锁。加锁后事务对数据对象有一定的控制，其他事务不能再对该数据对象有操作

#### 封锁类型

封锁的类型决定了对数据对象的控制。基本的封锁类型有两种
```排它锁(exclusive locks)```若事务T对数据对象AX锁，只允许T读取修改A，其他事务不能再对A加任何类型的锁，直到T释放锁。保证了A在释放X锁前，其他事务不能对X读取和修改
```共享锁(share locks)```若事务T对数据对象A上加S锁，则T只可以读取A，不能修改，其他事务只能对A加S锁，不能对事务加X锁，直到A释放S锁。保证了A在释放S锁前，其他事务不能对A修改
相容矩阵

#### 封锁协议

什么是协议

什么是封锁协议
在运用X锁和S锁是遵循不同的规则，如持锁时间、何时加锁、何时释放等，这些规则被称为封锁协议

为什么要有封锁协议

封锁协议与系统的一致性级别
```一级封锁协议```
含义：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放锁。事务结束包括正常结束(commit)和非正常结束(rollback)。
一级封锁协议只能防止丢失修改，不能保证可重复读和脏读

```二级封锁协议```
含义：在一级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，```读完后```释放S锁
二级封锁协议防止丢失修改和防止脏读，不能保证可重复读
```三级封锁协议```
含义：在二级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，直到```事务结束```才释放
三级封锁协议解决了数据不一致的问题(不可重复读、脏数据和丢失修改的问题)

三级协议的主要区别在于什么操作需要申请封锁以及何时释放锁
不同的封锁协议使事务达到的一致性级别不同，封锁协议级别越高，事务一致性程度越高

#### 封锁的粒度


#### 封锁是如何保证并发调度的正确性的-采用两段锁协议



#### 封锁带来的问题-活锁与死锁

活锁
含义
如果事务T1封锁了数据R，事务T2又请求封锁R，则T2等待；T3有请求封锁R，等T1释放锁后，系统首先批准T3的请求......T2永远等待下去。
避免方法：采用先来先服务的策略。系统按请求的先后顺序来分配锁

死锁
含义
事务T1封锁了数据A，事务T2封锁了数据B，T1又想封锁B，发现B已被封锁，T1等待T2释放锁；T2又想封锁A，发现已被T1封锁，T2等待T1释放锁。这样T1等待T2，T2等待T1，两个事务永远不会结束。
产生死锁的原因是两个或多个事务已经封锁了一些数据对象，又请求已被其他事务封锁的数据对象，造成死等
解决死锁问题的方法
1.死锁的预防

```一次封锁法```
```顺序封锁法```

2.死锁的诊断与解除
```超时法```
```等待图法```


### 时间戳

### 乐观控制法

### 多版本并发控制

## 参考文献

[乐观锁论文](https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf)
[数据库概论(第五版) 王珊 萨师轩编著](null)
