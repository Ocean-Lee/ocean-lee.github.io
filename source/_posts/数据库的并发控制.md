---
title: 数据库的并发控制
date: 2019-08-01 00:33:44
categories:
- 数据库
tags: [数据库数据库系统概论,计算机基础,核心知识]
---

```markdown
1.为什么要对数据库进行并发控制
2.并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况
3.并发控制技术的目的是什么
4.```可串行化调度```和```可串行性``` 的联系与区别。
5.调度的可串行性存在的原因，如何保证并发调度的可串行性
6.并发控制方法有哪些，每种方法是如何实现的，每种方法的优缺点是什么，并发控制方法解决了什么问题
```

## 事务的并行运行带来的问题

数据对象对事务来说是共享资源，事务在并发运行时容易造成数据不一致的问题。数据不一致可分为三类：修改丢失、不可重复读和脏读。
事务的并行运行破坏了事务的隔离性和一致性。

通过一个具体的实例来理解一下数据不一致
a.甲售票点读出某航班剩余票数A，设A=16
b.乙售票点读出统一航班剩余票数A，A也是16
c.甲售票点卖出一张票，修改剩余票数A=A-1=15，将剩余票数写回数据库
d.乙售票点卖出一张票，修改剩余票数A=A-1=15，将剩余票数写回数据库

此时发现明明卖出了两张票，剩余票数却只修改了1，破坏了数据库的一致性

数据的不一致性表现为

* ```丢失修改```
  两个事务(T1,T2)同时读取A的值,T2的提交结果破坏了T1的提交结果，导致T1的修改丢失
  
* 不可重复读
  根据事务T2的操作(修改、删除、新增)，可细分为三种情况
  事务T1读取数据A后，事务T2提交了对A的修改，导致事务T1读取的A值与之前不一样
  事务T1读取数据A后，事务T2提交了对A的删除，导致事务T1读不到A的值
  事务T1读取数据A后，事务T2提交了对A的新增，导致事务T1读到了两个A值

  后两种情况又称为幻影现象

* 脏读(读不正确的数据)
  事务T1修改了A的值并提交，事务T2读取A的值，此时事务T1因为某种原因撤销提交，A恢复原值，T2读到的数据A与数据库中的数据A不一致

## 并发调度的可串行性

### 问题

不同事务的调度是由DBMS来完成的。DBMS对事务不同的调度策略可能会产生不同的结果，那么什么样的调度是正确的的呢？

### 可串行化调度

#### 什么是可串行化调度

多个事务的并发结果是正确的，当且仅当其结果与按某一次序串行执行这些事务的结果相同时，则称这次的调度策略是可串行化的

```可串行性```是并发事务正确调度的准则。一个给定的并发调度，当且仅当他是```可串行化```的，才认为他是```正确调度```

#### 冲突操作

冲突操作是指不同事务对同一数据对象的读写操作和写写操作，其他操作是非冲突操作
```不同事务的冲突操作和同一事务的两个操作是不能交换的```

#### 具有什么样性质的调度是可串行化的调度，如何判断调度是可串行化的调度

一个调度Sc在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作，得到一个新的调度Sc'，若Sc'是串行的，则Sc'被称为冲突可串行化的调度
```若一个调度是冲突可串行化，则这个调度是可串行化调度```
```冲突可串行化调度是可串行化调度的充分条件。存在不满足冲突可串行化条件的可串行化调度```

举例来说明以上内容

## 并发控制的技术

### 目的

解决数据不一致的问题，保证调度的可串行性

* 封锁(locking)
* 时间戳(timestamp)
* 乐观控制法(optimistc scheduler)
* 多版本并发控制(multi-version concurrency contral ,MVCC)

### 封锁

含义
事务在访问数据对象(表、记录、字段)，向系统申请，对所要访问的数据对象加锁。加锁后事务对数据对象有一定的控制。

封锁类型
封锁的类型决定了对数据对象的控制
排它锁(exclusive locks)
共享锁(share locks)

封锁协议
规则

活锁与死锁

是

### 时间戳

### 乐观控制法

### 多版本并发控制

## 参考文献

[乐观锁论文](https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf)
[数据库概论(第五版) 王珊 萨师轩编著](null)
