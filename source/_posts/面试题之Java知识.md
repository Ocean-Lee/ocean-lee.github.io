---
title: 面试题之Java基础知识
date: 2019-06-17 15:54:55
categories:
- 面试题
tags: [Java面试题]
---

### Java基础知识

```markdown
1. 为什么需要public staic void main(String[] args)这个方法

Answer:这个方法是Java程序的入口，JVM在运行时按照上面的方法签名(必须有staic和public修饰，返回值必须是void，参数列表必须是字符串数组)查找方法的入口地址。
因为要调用类中的方法必须要实例化该类，而main是程序的入口，此时还没有实例化对象，因此要在不实例化对象的前提下调用main方法，所以main方法前要加staic和public

注：
a. main方法前面的staic和public没有顺序要求
b. main方法可以被final和synchronized修饰
c. main一定要被public和static修饰，一定不能被abstract修饰
d. 若一个.java文件中含有多个类，则只有与文件名相同的被public修饰的类中的main方法才是程序的入口
```

```markdown
2. 如何实现在main()方法执行前输出"Hello World"

Answer:
在类加载完成时，调main方法之前

Reference：
类加载
```

```markdown
3. Java程序初始化的顺序是怎么样的（一个类的初始化顺序是怎么样的）？

Answer:
把握住一个大方向：
变量->代码块->对象的构造函数

记住三个原则：
a.静态对象(变量)优于非静态对象(变量)的初始化,其中静态对象(变量)只初始化一次，非静态对象(变量)可以初始化多次
b.父类优先于子类初始化
c.按照成员变量的定义顺序进行初始化

记住一个事例
父类静态变量->父类静态代码块->子类静态变量->子类静态代码块->父类非静态变量->父类非静态代码块->父类构造方法->子类非静态变量->子类非静态代码块->子类构造方法

Reference：
类加载过程

```

```markdown
4. Java中的作用域有哪些

声明在不同位置的变量具有不同的作用域，作用域指变量的生命周期或可见性

Answer:

Java中变量的作用域是指变量的生命周期和可见性。Java中的变量分为三种：静态变量（全局变量）、成员变量、局部变量

a.静态变量的作用域
在类加载的时候，JVM为静态变量分配存储空间，静态变量不属于任何特定实例，而是被所有实例共享

b.成员变量的作用域
与类的实例化对象的作用范围相同。当类完成实例化，成员变量就会在内存中分配空间并初始化，直到对象被回收，成员变量的生命周期才会结束

c.局部变量的作用域
所在的花括号内

Java中提供四个关键字来保证变量的可见性

public  当前类 同一个包  子类  其他包  都可见
private 只在当前类中可见
protected 当前类，同一包、子类中可见
default  当前类、同一包可见，子类、其他包中


注意：
a.public、private、protected、default不能修饰局部变量
b.private和protected不能修饰类，只有public、final和abstract可以修饰类

```


```markdown
5. 一个Java文件中是否可以定义多个类

Answer:
一个Java文件中可以定义多个类。但是有且仅有一个类被public修饰且被修饰的类与Java文件的文件名相同。
若所有类未被public修饰，则java文件名随便是一个类的文件名即可

```

```markdown
6. 什么是构造函数

Answer：
构造函数是一种特殊的函数，用来在对象实例化的时候初始化对象的成员变量

构造函数的特点
a. 特殊的函数，与类同名且没有返回值（返回值也不能为void）
b. 每个类可以有多个构造方法，每个构造方法可以有至少零个参数，若没有提供构造器，编译器默认提供一个无参数的构造方法
c. new操作可以调用构造函数，不能在代码中直接调用
d. 构造函数的主要目的是完成对象的初始化工作
e. 构造函数不能被继承，因此，子类不能重写父类的构造函数
f. 如果父类中没有默认的的构造函数，则在子类中一定要显示的用super显示调用父类的构造函数。如果父类中有默认的构造函数，则在子类中可以不显示的调用super()
g. 默认构造函数的修饰符只与当前类的修饰符有关（若一个类被public修饰，则它的构造函数也是public）

Reference
```

```markdown
7. 为什么Java中有些接口没有任何方法（标记接口有什么用）

Answer：
问什么引入接口？什么是接口？接口有什么特征？
Java只支持单继承，为了弥补单继承的缺陷引入接口，一个类可以实现多个接口
接口是一种特殊的抽象方法，接口中只包含方法的定义，不包含方法的实现（接口中的常量值默认使用public static final修饰,方法默认使用public修饰；Java8中在接口中可以包含default方法实现）
如果一个接口中没有任何方法定义，则该接口称为标记接口。标记接口是计算机科学中的一种设计思路，
标记接口的作用是：给实现它的类添加一个元数据信息，可以使用InstanceOf进行类型查询

Reference
查询一下关于标记接口的文献

```

```markdown
8. Java中的clone方法有什么作用(如何从已有的对象A创建出与A状态相同的对象，并且修改B的状态不会影响到A的状态)?

Answer：
Java中提供clone方法来实现这个需求

使用该方法的步骤
a.类要实现Cloneable接口
b.类中重写clone方法
c.在clone方法中调用父类的clone方法(super.clone)完成复制（备注：如果是深复制，还需要对对象中的非基本数据类型也调用clone()方法完成复制）

浅复制与深复制
浅复制：被复制的对象所有的值与原来的一样，所有对象的引用都指向原来的对象
深复制：被复制的对象所有的值与原来的一样，新对象的引用指向被复制的新对象

基本数据类型可以用浅克隆
非基本数据类型要用深克隆

```

```markdown
9. 什么是反射机制？

Answer:
实现在运行时对类进行装载（在运行时动态的创建对象），增加程序的灵活性。

引申问题
Q1:如何获取Class类？
a.Class.forName()
b.类名.class
c.实例.getClass()

Q2:Java创建对想的方式有哪些
a.通过new语句实例化
b.通过反射机制，newInstance
c.通过clone方法
d.通过反序列化

```

```markdown
10. package有什么作用？

Answer:
a.解决命名冲突
b.对类按功能进行分类，是项目组织更加清晰

注意：
a.package语句在源文件的第一行
b.javac命令编译源文件后，会将源文件移动到packagename下
c.java命令：java packagename.sourcename

```


```markdown
11. 继承和组合的区别

Answer:
目的：代码复用
```

```markdown
12. Java中提供了哪两种用于多态的机制（多态实现的机制是什么）？

Answer:
编译时多态和运行时多态
编译时多态是通过方法重载实现的
运行时多态是通过方法重写实现的
```

```markdown
13. 重载和重写有什么区别？

Answer:
重载特点
a.通过不同的方法参数来区分，不能通过方法的访问权限、返回类型和抛出的异常来区分
b.子类不能重载父类的private方法

重写特点
a.子类的函数名和参数、返回值和抛出的异常要与父类一致
b.子类不能重写父类的private方法

重载与重写的区别
a.重写要求参数列表相同；重载要求参数列表不同
b.重写中，调用方法体是根据对象的类型（对象对应存储空间类型）来决定；重载是根据调用时的实参表与形参表来选择方法体
```


```markdown
14. 抽象类和接口有什么区别？

Answer:

```

```markdown
15. this和super有什么区别？

Answer:
this指向当前实例对象，super指向当前实例对象的父对象
三种用途
a.普通引用
b.形参和成员变量重名，用this来区分；子类成员变量或方法与父类中的成员变量或方法重名，用super来区分
c.引用构造函数。this(参数)、super(参数)，调用响应的构造函数。特别注意this(参数)和super(参数),必须放在构造方法中的第一行
```

```markdown
16. 内部类有哪些？

思路：
从三个角度（内部类和外部类），理清楚下面的关系
a.变量（成员变量和静态变量）和方法（成员方法和静态方法）的定义
b.调用关系
变量之间的调用
方法之间的调用
方法中调用变量
c.实例化的先后顺序


Answer:
内部类有四种
a.静态内部类
静态内部类中关于变量和方法的定义与普通类没有区别
静态内部类可以直接访问外部类的静态变量和静态方法
静态内部类不依赖外部类实例而被实例化

b.成员内部类
成员内部类中只能定义成员变量和成员方法，不能定义静态变量和静态方法
成员内部类可以自由的访问外部类的变量和方法，无论是静态的还是非静态的
只有外部类被实例化了，成员内部类才能被实例化

c.局部内部类
定义在代码块中，只存活在当前的代码块中
只能访问代码块中的final变量

d.匿名内部类（没有类名的内部类）
匿名内部类使用原则
* 不能有构造函数
* 不能被class、implement、extend、public、protected、private、static关键字修饰
* 不能定义静态成员、方法、类
* new后面一定是一个匿名内部类必须继承其他类或实现其他接口
* 只能创建匿名内部类的一个实例
* 匿名内部类的本质是局部内部类

```

```markdown
17. 如何获取父类的类名

Answer:
Java中提供了对象.getClass.getName方法来获取类的名称。如果想获取父类的类名自然会想到如下方法
super.getClass.getName(),但是真的能够获取到父类的名称吗？不能。因为getClass方法来自Object类，getClass()
方法被final native 修饰，不能不子类重写，所以super.getClass()和this.getClass()调的都是Object的getClass()，而getClass()方法
是获取Object的运行时类，故super.getClass.getName()获取不到父类的名称

解决方法，通过反射机制，调用getClass().getSuperClass().getName来获取
```

