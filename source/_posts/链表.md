---
title: 链表
date: 2019-06-17 10:41:15
categories:
- 数据结构与算法
tags: [链表]
---
### 存储结构

链表是由若干的几点组成的，节点是包含元素信息和节点地址的集合。
链表的存储在内存中不是连续的，可以在程序运行期间，根据需求动态的创建节点，链表的长度在逻辑上没有限制，长度取决于内存容量

### 基本操作
 * 创建:头插法(逆序)、尾插法(顺序)
 * 修改:修改指定节点的值
 * 删除:删除指定节点的值
 * 遍历(或查询指定元素):遍历整个链表

### 链表节点定义

``` java
/**
 * 节点描述类
 */
public class Node {
    /**
     * 元素的值
     */
    int data;

    /**
     * 下一个节点地址
     */
    Node next;

    /**
     * 初始化一个节点
     */
    public Node() {
        this(0, null);
    }

    /**
     * @param data
     */
    public Node(int data) {
        this.data = data;
    }

    /**
     * @param data
     * @param next
     */
    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }
}
```

### 链表类型
1、单向链表

a. 插入
节点插入到头部 O(1)
节点插入到尾部 O(1)

b. 删除
删除头部结点 O(1)
删除尾部节点 O(n)
删除指定节点 最好情况，O(1),最坏和平均情况O(n)

单向链表存在的问题，无法获取指定节点的前驱节点地址，导致在执行删除尾部节点时，需要查找前去节点的地址，所以产生了双向链表

2、双向链表

本质上是空间换时间。降低了节点的存储密度，将尾删除的时间复杂度降低到了O(1)


3、循环链表

- 循环单向表
- 循环双向链表

```text
目前，还有一个待解决的问: 删除指定元素的优化(实质上是优化查询的效率)。删除指定元素包含两个操作
1、查找 O(n)
2、删除 O(1)
```

4、跳跃链表

#### 前言
```text
在链表中如何可以更快的查到元素呢？
排序可以加快查找的速度

为了解决这个问题，引入了跳跃链表，将查找的复杂度由O(n)降为O(log(n))
```

#### 什么是跳跃表

 参考链接 
 [MIT Introduction to Algorithms](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-12-skip-lists/) 
 [知乎-数据结构与算法-链表(下)](https://zhuanlan.zhihu.com/p/52841915)
 [redis源码解读(七)](http://czrzchao.com/redisSourceSkiplist)

前提：有序的单向链表
